## 数煤球

						煤球数目
		
		有一堆煤球，堆成三角棱锥形。具体：
		第一层放1个，
		第二层3个（排列成三角形），
		第三层6个（排列成三角形），
		第四层10个（排列成三角形），
		....
		如果一共有100层，共有多少个煤球？
		
		请填表示煤球总数目的数字。
		注意：你提交的应该是一个整数，不要填写任何多余的内容或说明性文字。

171700



## 生日蜡烛

							生日蜡烛
		
		某君从某年开始每年都举办一次生日party，并且每次都要吹熄与年龄相同根数的蜡烛。
		
		现在算起来，他一共吹熄了236根蜡烛。
		
		请问，他从多少岁开始过生日party的？
		
		请填写他开始过生日party的年龄数。
		注意：你提交的应该是一个整数，不要填写任何多余的内容或说明性文字。

26



## 凑算式

> ​       B      DEF
> A + --- + ------- = 10
> ​       C      GHI

这个算式中A~I代表1~9的数字，不同的字母代表不同的数字。

比如：
6+8/3+952/714 就是一种解法，
5+3/1+972/486 是另一种解法。

这个算式一共有多少种解法？
29

```java
package BBP;
import java.io.*;
import java.util.*;
public class Main{
	static int[] ans = new int[9];
	static int status[] = new int[10];
	static int count=0;
	public static void main(String args[]) {		
		dfs(0);
		System.out.print(count);
	}
	private static void dfs(int c) {
		
		if(c==9) {
			if(check()) {
				count++;				
			}
		}
		
		for(int i=1;i<10;i++) {
			if(status[i]!=1) {
				ans[c]=i;
				status[i]=1;
				dfs(c+1);
				status[i]=0;
			}
		}
		
	}
	private static boolean check() {
		int def = ans[3]*100+ans[4]*10+ans[5];
		int ghi = ans[6]*100+ans[7]*10+ans[8];
		if((ans[1]*ghi+ans[2]*def+ans[0]*ans[2]*ghi)/(ans[2]*ghi)==10&&(ans[1]*ghi+ans[2]*def+ans[0]*ans[2]*ghi)%(ans[2]*ghi)==0)//注意需要满足整除条件
			return true;
		
		return false;
	}
}
```



## 方格填数

方格填数
		
		如下的10个格子
		   +--+--+--+
		   |  |  |  |
		+--+--+--+--+
		|  |  |  |  |
		+--+--+--+--+
		|  |  |  |
		+--+--+--+
		
		（如果显示有问题，也可以参看下图）
		
		填入0~9的数字。要求：连续的两个数字不能相邻。
		（左右、上下、对角都算相邻）
		
		一共有多少种可能的填数方案？
		
		请填写表示方案数目的整数。
		
		注意：你提交的应该是一个整数，不要填写任何多余的内容或说明性文字。

全排列+特殊情况筛选，注意筛选条件中包含对角。

```java
package BBP;
import java.io.*;
import java.util.*;
public class Main{
	static int[] ans = new int[10];
	static int status[] = new int[10];
	static int count=0;
	public static void main(String args[]) {		
		dfs(0);
		System.out.print(count);
	}
	private static void dfs(int c) {
		
		if(c==10) {
			if(check()) {
				count++;				
			}
		}
		
		for(int i=0;i<10;i++) {
			if(status[i]!=1) {
				ans[c]=i;
				status[i]=1;
				dfs(c+1);
				status[i]=0;
			}
		}
		
	}
	private static boolean check() {
		if(Math.abs(ans[4]-ans[0])==1||Math.abs(ans[1]-ans[0])==1)
			return false;
		if(Math.abs(ans[5]-ans[1])==1||Math.abs(ans[2]-ans[1])==1)
			return false;
		if(Math.abs(ans[6]-ans[2])==1)
			return false;
		if(Math.abs(ans[7]-ans[3])==1||Math.abs(ans[4]-ans[3])==1)
			return false;
		if(Math.abs(ans[8]-ans[4])==1||Math.abs(ans[5]-ans[4])==1)
			return false;
		if(Math.abs(ans[9]-ans[5])==1||Math.abs(ans[6]-ans[5])==1)
			return false;
		if(Math.abs(ans[8]-ans[3])==1||Math.abs(ans[5]-ans[8])==1)
			return false;
		if(Math.abs(ans[0]-ans[3])==1||Math.abs(ans[5]-ans[0])==1)
			return false;
		if(Math.abs(ans[5]-ans[2])==1||Math.abs(ans[6]-ans[5])==1)
			return false;
		if(Math.abs(ans[9]-ans[4])==1||Math.abs(ans[4]-ans[7])==1)
			return false;
		if(Math.abs(ans[1]-ans[4])==1||Math.abs(ans[6]-ans[1])==1)
			return false;
		if(Math.abs(ans[9]-ans[8])==1||Math.abs(ans[8]-ans[7])==1)
			return false;
		if(Math.abs(ans[9]-ans[6])==1||Math.abs(ans[8]-ans[7])==1)
			return false;
		
		return true;
	}
}
```



## 剪邮票

> 剪邮票
>
> 如【图1.jpg】, 有12张连在一起的12生肖的邮票。
> 现在你要从中剪下5张来，要求必须是连着的。
> （仅仅连接一个角不算相连）
> 比如，【图2.jpg】，【图3.jpg】中，粉红色所示部分就是合格的剪取。
>
> 请你计算，一共有多少种不同的剪取方法。
>
> 请填写表示方案数目的整数。
> 注意：你提交的应该是一个整数，不要填写任何多余的内容或说明性文字。



## 四平方和

四平方和定理，又称为拉格朗日定理：
		每个正整数都可以表示为至多4个正整数的平方和。
		如果把0包括进去，就正好可以表示为4个数的平方和。
		

		比如：
		5 = 0^2 + 0^2 + 1^2 + 2^2
		7 = 1^2 + 1^2 + 1^2 + 2^2
		（^符号表示乘方的意思）
		
		对于一个给定的正整数，可能存在多种平方和的表示法。
		要求你对4个数排序：
		0 <= a <= b <= c <= d
		并对所有的可能表示法按 a,b,c,d 为联合主键升序排列，最后输出第一个表示法
		
		程序输入为一个正整数N (N<5000000)
		要求输出4个非负整数，按从小到大排序，中间用空格分开
		
		例如，输入：
		5
		则程序应该输出：
		0 0 1 2
		
		再例如，输入：
		12
		则程序应该输出：
		0 2 2 2
		
		再例如，输入：
		773535
		则程序应该输出：
		1 1 267 838




## 取球博弈

> 取球博弈
>
> 两个人玩取球的游戏。
> 一共有N个球，每人轮流取球，每次可取集合{n1,n2,n3}中的任何一个数目。
> 如果无法继续取球，则游戏结束。
> 此时，持有奇数个球的一方获胜。
> 如果两人都是奇数，则为平局。
>
> 假设双方都采用最聪明的取法，
> 第一个取球的人一定能赢吗？
> 试编程解决这个问题。
>
> 输入格式：
> 第一行3个正整数n1 n2 n3，空格分开，表示每次可取的数目 (0<n1,n2,n3<100)
> 第二行5个正整数x1 x2 ... x5，空格分开，表示5局的初始球数(0<xi<1000)
>
> 输出格式：
> 一行5个字符，空格分开。分别表示每局先取球的人能否获胜。
> 能获胜则输出+，
> 次之，如有办法逼平对手，输出0，
> 无论如何都会输，则输出-
>
> 例如，输入：
> 1 2 3
> 1 2 3 4 5
>
> 程序应该输出：
> + 0 + 0 -
>
> 再例如，输入：
> 1 4 5
> 10 11 12 13 15
>
> 程序应该输出：
> 0 - 0 + +
>
> 再例如，输入：
> 2 3 5
> 7 8 9 10 11
>
> 程序应该输出：
> + 0 0 0 0
>
>
> 资源约定：
> 峰值内存消耗（含虚拟机） < 256M
> CPU消耗  < 3000ms
>
>
> 请严格按要求输出，不要画蛇添足地打印类似：“请您输入...” 的多余内容。
>
> 所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。
> 注意：不要使用package语句。不要使用jdk1.7及以上版本的特性。
> 注意：主类的名字必须是：Main，否则按无效代码处理。



## 压缩变换

> 小明最近在研究压缩算法。
> 他知道，压缩的时候如果能够使得数值很小，就能通过熵编码得到较高的压缩比。
> 然而，要使数值很小是一个挑战。
>
> 最近，小明需要压缩一些正整数的序列，这些序列的特点是，后面出现的数字很大可能是刚出现过不久的数字。对于这种特殊的序列，小明准备对序列做一个变换来减小数字的值。
>
> 变换的过程如下：
> 从左到右枚举序列，每枚举到一个数字，如果这个数字没有出现过，刚将数字变换成它的相反数，如果数字出现过，则看它在原序列中最后的一次出现后面（且在当前数前面）出现了几种数字，用这个种类数替换原来的数字。
>
> 比如，序列(a1, a2, a3, a4, a5)=(1, 2, 2, 1, 2)在变换过程为：
> a1: 1未出现过，所以a1变为-1；
> a2: 2未出现过，所以a2变为-2；
> a3: 2出现过，最后一次为原序列的a2，在a2后、a3前有0种数字，所以a3变为0；
> a4: 1出现过，最后一次为原序列的a1，在a1后、a4前有1种数字，所以a4变为1；
> a5: 2出现过，最后一次为原序列的a3，在a3后、a5前有1种数字，所以a5变为1。
> 现在，给出原序列，请问，按这种变换规则变换后的序列是什么。
>
> 输入格式：
> 输入第一行包含一个整数n，表示序列的长度。
> 第二行包含n个正整数，表示输入序列。
>
> 输出格式：
> 输出一行，包含n个数，表示变换后的序列。
>
> 例如，输入：
> 5
> 1 2 2 1 2
>
> 程序应该输出：
> -1 -2 0 1 1
>
> 再例如，输入：
> 12
> 1 1 2 3 2 3 1 2 2 2 3 1
>
> 程序应该输出：
> -1 0 -2 -3 1 1 2 2 0 0 2 2
>
> 数据规模与约定
> 对于30%的数据，n<=1000；
> 对于50%的数据，n<=30000；
> 对于100%的数据，1 <=n<=100000，1<=ai<=10^9