模板

```java
 public static int bfs() {
        初始化队列

        加入起点0, 0
   
        while (队列不为0) {
            队列pop
            判断是否满足输出条件

          	//上左下右 遍历所有可能
            for (  ) {
                如果符合条件，加入队列
                }
```

> 定义 数据标记集合 mark_list
> 定义 搜索规则 search_func
> 定义 待搜索队列 queue ，并将搜索起点载入
> 定义 当前级数 level
> 遍历 queue：
> 得到当前 level 的待搜索的全部数据，并对其挨个搜索：
> 得到队首 待搜索元素 head_data
> 通过搜索规则得到下一个元素 next_data
> 判断 next_data 是否为终点数据 若是：返回 level
> 判断 next_data 是否在范围内 若否：跳出当前循环（continue/pass）
> 判断 next_data 是否在mark_list 若否：添加 next_data 至mark_list和 queue （还有一种情况是mark_list 采用已知条件，即初始为满，若 next_data 在mark_list ，则将其删去）

## 八数码

在一个3×3的网格中，1~8这8个数字和一个“X”恰好不重不漏地分布在这3×3的网格中。

例如：

> 1 2 3
> X 4 6
> 7 5 8

在游戏过程中，可以把“X”与其上、下、左、右四个方向之一的数字交换（如果存在）。

我们的目的是通过交换，使得网格变为如下排列（称为正确排列）：

> 1 2 3
> 4 5 6
> 7 8 X

例如，示例中图形就可以通过让“X”先后与右、下、右三个方向的数字交换成功得到正确排列。

交换过程如下：

> 1 2 3      1 2 3         1 2 3       1 2 3
> X 4 6  ->  4 X 6  ->  4 5 6  ->  4 5 6
> 7 5 8      7 5 8          7 X 8      7 8 X

现在，给你一个初始网格，请你求出得到正确排列至少需要进行多少次交换。

##### 问题分析：

1. 状态标识复制：利用map<String,int>标记排列方式和距离
2. 如何记录每个状态的距离 ：创建数组

```java
```

